import numpy as np
import scipy.stats as stats

np.random.seed(42)  # For reproducibility

# Parameters
mu = 10
sigma = 2
sample_sizes = [5, 10, 20, 40, 80, 160, 1000]
confidence_level = 0.95
alpha = 1 - confidence_level
z_critical = stats.norm.ppf(1 - alpha/2)
num_bootstrap_samples = 10000

# Non-informative prior for Bayesian method
bayes_prior_mu = 0
bayes_prior_sigma2 = 1e6  # Very vague prior

results = []

for n in sample_sizes:
    sample = np.random.normal(mu, sigma, n)
    sample_mean = np.mean(sample)
    sample_std = np.std(sample, ddof=1)
    stderr = sample_std / np.sqrt(n)

    # 1. Z Interval (known sigma)
    z_margin = z_critical * (sigma / np.sqrt(n))
    z_ci = (sample_mean - z_margin, sample_mean + z_margin)

    # 2. t Interval (unknown sigma)
    t_critical = stats.t.ppf(1 - alpha/2, df=n-1)
    t_margin = t_critical * stderr
    t_ci = (sample_mean - t_margin, sample_mean + t_margin)

    # 3. Bootstrap Percentile CI
    bootstrap_means = np.array([
        np.mean(np.random.choice(sample, size=n, replace=True))
        for _ in range(num_bootstrap_samples)
    ])
    bootstrap_ci = (
        np.percentile(bootstrap_means, 100 * alpha/2),
        np.percentile(bootstrap_means, 100 * (1 - alpha/2))
    )

    # 4. Bayesian Credible Interval (normal conjugate prior)
    post_var = 1 / (n / sigma**2 + 1 / bayes_prior_sigma2)
    post_mean = post_var * (np.sum(sample) / sigma**2 + bayes_prior_mu / bayes_prior_sigma2)
    post_std = np.sqrt(post_var)
    bayes_ci = (post_mean - z_critical * post_std, post_mean + z_critical * post_std)

    results.append({
        "n": n,
        "Z CI": z_ci,
        "t CI": t_ci,
        "Bootstrap CI": bootstrap_ci,
        "Bayesian CI": bayes_ci
    })

# Print results
for r in results:
    print(f"n = {r['n']}")
    print(f"  Z CI        : {r['Z CI']}")
    print(f"  t CI        : {r['t CI']}")
    print(f"  Bootstrap CI: {r['Bootstrap CI']}")
    print(f"  Bayesian CI : {r['Bayesian CI']}")
    print()
